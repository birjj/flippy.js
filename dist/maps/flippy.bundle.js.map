{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///flippy.bundle.js","webpack:///webpack/bootstrap 477e93a845dd72578e59","webpack:///./src/element.js","webpack:///./src/flippy.js","webpack:///./src/helpers.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","length","descriptor","writable","key","protoProps","staticProps","_helpers","elmMap","Map","FLIPElement","elm","options","HTMLElement","has","self","opts","setOptions","set","_style","assign","duration","ease","animatingClass","scalingClass","useScale","_playing","stop","_first","getSnapshot","debug","Error","_last","willChange","style","transform","transformOrigin","transition","getTransitionFromElm","width","height","k","delta","getDelta","translation","left","toFixed","top","scaling","join","_playPart1","offsetHeight","_applyTransition","_playPart2","_checkMoved","_animCb","callback","_this","classList","add","_onTransitionEnd","e","propertyName","_timerFallback","setTimeout","addEventListener","Math","abs","filter","Boolean","clearTimeout","removeEventListener","clean","finish","remove","method","meta","console","log","default","elms","modifier","arguments","undefined","Array","Function","from","document","querySelectorAll","groupCollapsed","finalCallback","finalPromise","Promise","res","optCallback","numCalls","map","forEach","first","last","invert","body","offsetTop","groupEnd","fromCenter","pos","getClientRect","styles","window","getComputedStyle","alpha","beta","rect","offsetWidth","offsetLeft","_isFixed","position","offsetParent","documentElement","doc","pageXOffset","scrollLeft","clientLeft","pageYOffset","scrollTop","clientTop","transitionProperty","transitionDuration","transitionTimingFunction","transitionDelay"],"mappings":"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","file":"flippy.bundle.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"flip\"] = factory();\n\telse\n\t\troot[\"flip\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"flip\"] = factory();\n\telse\n\t\troot[\"flip\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _helpers = __webpack_require__(2);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/** @type {Map<HTMLElement, FLIPElement>} */\nvar elmMap = new Map();\n\n/**\n * Handler for a single element in a FLIP animation\n */\n\nvar FLIPElement = function () {\n    function FLIPElement(elm, options) {\n        _classCallCheck(this, FLIPElement);\n\n        if (!(elm instanceof HTMLElement)) {\n            throw new TypeError(\"Element must be an HTMLElement\");\n        }\n        if (elmMap.has(elm)) {\n            var self = elmMap.get(elm);\n            this.opts = {}; // remove old options\n            self.setOptions(options);\n            return self;\n        }\n\n        this.setOptions(options);\n        elmMap.set(elm, this);\n\n        this.elm = elm;\n        this._style = {};\n    }\n\n    /**\n     * Applies options\n     * @param {Object} options The options object\n     * @param {Number} [options.duration=400] Length of animation in milliseconds\n     * @param {String} [options.ease=\"ease\"] CSS timing function to use for easing\n     * @param {String} [options.animatingClass=\"flip-animating\"] Class to apply when animating\n     * @param {String} [options.scalingClass=\"flip-scaling\"] Class to apply when scaling\n     * @param {Boolean} [options.useScale=true] Whether we should animate width/height changes by scaling\n     */\n\n\n    _createClass(FLIPElement, [{\n        key: \"setOptions\",\n        value: function setOptions(options) {\n            this.opts = Object.assign({}, {\n                duration: 400,\n                ease: \"ease\",\n                animatingClass: \"flip-animating\",\n                scalingClass: \"flip-scaling\",\n                useScale: true\n            }, this.opts, options);\n        }\n\n        /**\n         * Snapshot an elements initial position\n         * Stored in ._first\n         */\n\n    }, {\n        key: \"first\",\n        value: function first() {\n            if (this._playing) {\n                this.stop();\n            }\n            this._first = (0, _helpers.getSnapshot)(this.elm, this.opts.useScale);\n            this.debug(\"first\", this._first);\n\n            return this;\n        }\n\n        /**\n         * Snapshot an elements final position\n         * Stored in ._last\n         */\n\n    }, {\n        key: \"last\",\n        value: function last() {\n            if (!this._first) {\n                throw new Error(\".first() must be called before .last()\");\n            }\n            this._last = (0, _helpers.getSnapshot)(this.elm, this.opts.useScale);\n            this.debug(\"last\", this._last);\n\n            // save old styles for when we remove flip\n            this._style.willChange = this.elm.style.willChange;\n            this._style.transform = this.elm.style.transform;\n            this._style.transformOrigin = this.elm.style.transformOrigin;\n            this._style.transition = (0, _helpers.getTransitionFromElm)(this.elm);\n            this._style.width = this.elm.style.width;\n            this._style.height = this.elm.style.height;\n\n            for (var k in this._style) {\n                var style = this._style[k];\n                this._style[k] = style && style !== \"none\" ? style : \"\";\n            }\n\n            return this;\n        }\n\n        /**\n         * Applies a transform from ._last => ._first\n         * This moves the element back to where it was\n         */\n\n    }, {\n        key: \"invert\",\n        value: function invert() {\n            if (!this._first || !this._last) {\n                throw new Error(\".first() and .last() must be called before .invert()\");\n            }\n\n            var delta = (0, _helpers.getDelta)(this._first, this._last);\n            var translation = \"translate(\" + delta.left.toFixed(2) + \"px, \" + delta.top.toFixed(2) + \"px)\";\n            var scaling = this.opts.useScale ? \"scale(\" + delta.width.toFixed(2) + \", \" + delta.height.toFixed(2) + \")\" : \"\";\n\n            this.elm.style.transformOrigin = \"50% 50%\";\n            // if the original transform contains rotates, we need to move first\n            // (so it moves along the non-rotated axis) and scale last (so it scales\n            // along the rotated axis)\n            this.elm.style.transform = [translation, this._first.transform, scaling].join(\" \");\n            this.elm.style.willChange = \"transform\";\n\n            // If we shouldn't scale, we should animate width/height instead\n            if (!this.opts.useScale) {\n                this.elm.style.width = this._first.width.toFixed(2) + \"px\";\n                this.elm.style.height = this._first.height.toFixed(2) + \"px\";\n            }\n\n            this.debug(\"invert\", this.elm.style.transform);\n\n            return this;\n        }\n\n        /**\n         * Plays back the animation\n         */\n\n    }, {\n        key: \"play\",\n        value: function play() {\n            if (this._playPart1() === false) {\n                return this;\n            }\n\n            this.elm.offsetHeight;\n            this._applyTransition();\n            this.elm.offsetHeight;\n\n            this._playPart2();\n\n            return this;\n        }\n\n        /**\n         * Same as .play() up until the first reflow\n         * Useful if you're animating multiple elements\n         * @returns {Boolean} If false, play is stopped\n         */\n\n    }, {\n        key: \"_playPart1\",\n        value: function _playPart1() {\n            if (this._playing) {\n                this.stop();\n            }\n            this._playing = true;\n\n            if (!this._checkMoved()) {\n                this.debug(\"Ending early because of no change\");\n                this._animCb = this.opts.callback;\n                this.stop();\n                return false;\n            }\n            return true;\n        }\n\n        /**\n         * Same as .play() after the last reflow\n         * Useful if you're animating multiple elements\n         * @returns {Boolean} If false, play is stopped\n         */\n\n    }, {\n        key: \"_playPart2\",\n        value: function _playPart2() {\n            var _this = this;\n\n            // add our animation classes\n            this.elm.classList.add(this.opts.animatingClass);\n            if (this._first.width !== this._last.width || this._first.height !== this._last.height) {\n                this.elm.classList.add(this.opts.scalingClass);\n            }\n\n            // animate to end position\n            this.elm.style.transform = this._last.transform;\n            if (!this.opts.useScale) {\n                this.elm.style.width = this._last.width.toFixed(2) + \"px\";\n                this.elm.style.height = this._last.height.toFixed(2) + \"px\";\n            }\n\n            // if cb changes before animation finishes, cache it here\n            // this could e.g. happen if we start a new animation\n            this._animCb = this.opts.callback;\n\n            this._onTransitionEnd = function (e) {\n                if (e.target === _this.elm && e.propertyName === \"transform\") {\n                    _this.stop();\n                }\n            };\n\n            // in case transitionend isn't called (element is removed, etc.)\n            // use a timer fallback which is slightly delayed but avoids\n            // missing callbacks\n            this._timerFallback = setTimeout(function () {\n                return _this._onTransitionEnd({\n                    target: _this.elm,\n                    propertyName: \"transform\"\n                });\n            }, this.opts.duration + 100);\n            // wait for transitionend\n            this.elm.addEventListener(\"transitionend\", this._onTransitionEnd);\n\n            return true;\n        }\n\n        /**\n         * Check if we actually moved from first to last\n         */\n\n    }, {\n        key: \"_checkMoved\",\n        value: function _checkMoved() {\n            // if we're not moving at all, just end without playing\n            if (Math.abs(this._first.left - this._last.left) <= 1 && Math.abs(this._first.top - this._last.top) <= 1 && Math.abs(this._first.width - this._last.width) <= 1 && Math.abs(this._first.height - this._last.height) <= 1) {\n                return false;\n            }\n            return true;\n        }\n\n        /**\n         * Applies our transition to the element\n         * Page should be reflowed before and after this is called\n         */\n\n    }, {\n        key: \"_applyTransition\",\n        value: function _applyTransition() {\n            var duration = (this.opts.duration / 1000).toFixed(2);\n            this.elm.style.transition = [this._style.transition, \"transform \" + duration + \"s \" + this.opts.ease, !this.opts.useScale ? \"width \" + duration + \"s \" + this.opts.ease : \"\", !this.opts.useScale ? \"height \" + duration + \"s \" + this.opts.ease : \"\"].filter(Boolean).join(\", \");\n        }\n\n        /**\n         * Stops an in-progress animation\n         */\n\n    }, {\n        key: \"stop\",\n        value: function stop() {\n            clearTimeout(this._timerFallback);\n            this.elm.removeEventListener(\"transitionend\", this._onTransitionEnd);\n            this.clean().finish();\n            return this;\n        }\n\n        /**\n         * Removes all FLIP-related data from element\n         */\n\n    }, {\n        key: \"clean\",\n        value: function clean() {\n            this._first = null;\n            this._last = null;\n\n            this.elm.classList.remove(this.opts.animatingClass, this.opts.scalingClass);\n            this.elm.style.transition = this._style.transition;\n            this.elm.style.transformOrigin = this._style.transformOrigin;\n            this.elm.style.willChange = this._style.willChange;\n            this.elm.style.width = this._style.width;\n            this.elm.style.height = this._style.height;\n\n            // Firefox keeps playing playing a transition after it's removed\n            // To stop this, we change transform, reflow and then set it to what we want\n            this.elm.style.transform = this._style.transform ? \"\" : \"translateX(10px)\";\n            this.elm.offsetHeight;\n            this.elm.style.transform = this._style.transform;\n\n            return this;\n        }\n\n        /**\n         * Called when the animation is finished\n         * @param {Function} [callback]\n         */\n\n    }, {\n        key: \"finish\",\n        value: function finish() {\n            this._playing = false;\n            if (this._animCb) {\n                this._animCb();\n                this._animCb = null;\n            }\n        }\n\n        /**\n         * Logs debug info\n         */\n\n    }, {\n        key: \"debug\",\n        value: function debug(method, meta) {\n            if (this.opts.debug) {\n                console.log(\"[\", this.elm, \"] \", method, meta);\n            }\n        }\n    }]);\n\n    return FLIPElement;\n}();\n\nexports.default = FLIPElement;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * FLIP animation helper\n * See https://aerotwist.com/blog/flip-your-animations/\n *\n * Animation principle by Paul Lewis\n * Code by Birjolaxew\n */\n\n\n// cannot use import/export because of webpack/webpack#706\n\nvar FLIPElement = __webpack_require__(0).default;\n\n/**\n * Animates DOM changes on specified elements\n * @param {Element|Array<Element>|String} elms  Element(s) to animate\n * @param {Function} modifier   Is called when the DOM should change\n * @param {Object} [options]    Various additional options\n * @param {Function} [options.callback] A function to be called when animation\n *                                      is done. Receives elms as parameter.\n * @param {Number} [options.duration=400] The length of the animation in milliseconds.\n * @param {String} [options.ease=\"ease\"] The CSS timing function to use\n * @param {String} [options.animatingClass=\"flip-animating\"]\n * @param {String} [options.scalingClass=\"flip-scaling\"]\n * \n * @return {Promise<Array<Element>>}    A Promise which resolves once animation \n *                                      is done.\n */\nmodule.exports = function flip(elms, modifier) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (!elms || typeof elms !== \"string\" && !(elms instanceof Array) && !(elms instanceof HTMLElement)) {\n        throw new TypeError(\"Elements must be a string, array or element\");\n    }\n    if (!modifier || !(modifier instanceof Function)) {\n        throw new TypeError(\"Modifier must be a function\");\n    }\n\n    // normalize all input types to {Array<Element>}\n    if (typeof elms === \"string\") {\n        elms = Array.from(document.querySelectorAll(elms));\n    } else if (elms instanceof HTMLElement) {\n        elms = [elms];\n    }\n\n    if (options.debug && console.groupCollapsed) {\n        console.groupCollapsed();\n    }\n\n    // make our callback a collective callback\n    var finalCallback = void 0;\n    var finalPromise = new Promise(function (res) {\n        finalCallback = function finalCallback() {\n            if (optCallback) {\n                optCallback();\n            }\n            res();\n        };\n    });\n    var optCallback = options.callback;\n    var numCalls = elms.length;\n    options.callback = function () {\n        if (--numCalls <= 0) {\n            finalCallback();\n        }\n    };\n\n    // convert to {Array<FLIPElement>}\n    elms = elms.map(function (elm) {\n        if (!(elm instanceof HTMLElement)) {\n            throw new TypeError(\"Array must only contain elements\");\n        }\n        return new FLIPElement(elm, options);\n    });\n\n    // ===\n    // FLIP elements\n    // ===\n    elms.forEach(function (elm) {\n        return elm.first();\n    }); // reflow: read\n    modifier(); // reflow: write\n    elms.forEach(function (elm) {\n        return elm.last();\n    }); // reflow: read\n    elms.forEach(function (elm) {\n        return elm.invert();\n    }); // reflow: write\n    elms = elms.map(function (elm) {\n        // reflow: write\n        if (elm._playPart1() === false) {\n            options.callback();\n            return false;\n        }\n        return elm;\n    }).filter(Boolean);\n    document.body.offsetTop; // force reflow\n    elms.forEach(function (elm) {\n        return elm._applyTransition();\n    }); // reflow: write\n    document.body.offsetTop; // force reflow\n    elms.forEach(function (elm) {\n        return elm._playPart2();\n    });\n\n    if (options.debug && console.groupCollapsed) {\n        console.groupEnd();\n    }\n\n    // return a Promise\n    return finalPromise;\n};\nmodule.exports.FLIPElement = FLIPElement;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Gets a snapshot of an element\n * Returns an object with format\n * {\n *   left: <Number>, top: <Number>,\n *   width: <Number>, height: <Number>,\n *   transform: <String>\n * }\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getSnapshot = getSnapshot;\nexports.getDelta = getDelta;\nexports.getClientRect = getClientRect;\nexports.getTransitionFromElm = getTransitionFromElm;\nfunction getSnapshot(elm, fromCenter) {\n    var pos = getClientRect(elm);\n    var styles = window.getComputedStyle(elm);\n    return { // positions are related to center\n        left: pos.left + (fromCenter ? pos.width / 2 : 0),\n        top: pos.top + (fromCenter ? pos.height / 2 : 0),\n        width: pos.width,\n        height: pos.height,\n\n        transform: styles.transform === \"none\" || !styles.transform ? \"\" : styles.transform\n    };\n}\n\n/**\n * Gets the difference between two snapshots\n * Width/height are scales, left/top are pixel differences\n */\nfunction getDelta(alpha, beta) {\n    var delta = {\n        left: alpha.left - beta.left,\n        top: alpha.top - beta.top,\n        width: alpha.width / beta.width,\n        height: alpha.height / beta.height\n    };\n\n    if (alpha.width === 0 && alpha.height === 0) {\n        // the element probably wasn't in the DOM at the time\n        // don't animate left/top\n        delta.left = delta.top = 0;\n    }\n\n    return delta;\n}\n\n/**\n * Returns the client rectangle of an element w/o transforms\n */\nfunction getClientRect(elm) {\n    var rect = {\n        width: elm.offsetWidth,\n        height: elm.offsetHeight,\n        left: elm.offsetLeft,\n        top: elm.offsetTop\n    };\n    var _isFixed = window.getComputedStyle(elm).position === \"fixed\";\n\n    // offsetLeft/-Top relates to the offsetParent\n    // we want it to relate to the window\n    while ((elm = elm.offsetParent) && elm !== document.body && elm !== document.documentElement) {\n        rect.left += elm.offsetLeft;\n        rect.top += elm.offsetTop;\n    }\n\n    // fixed elements have .offsetParent === body\n    if (_isFixed) {\n        var doc = document.documentElement;\n        rect.left += (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);\n        rect.top += (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);\n    }\n\n    return rect;\n}\n\n/**\n * Get the applied transition from an element\n * @returns {String}\n */\nfunction getTransitionFromElm(elm) {\n    var styles = window.getComputedStyle(elm);\n    return styles.transitionProperty + \" \" + styles.transitionDuration + \" \" + styles.transitionTimingFunction + \" \" + styles.transitionDelay;\n}\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// flippy.bundle.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 477e93a845dd72578e59","\"use strict\";\nimport { getSnapshot, getDelta, getTransitionFromElm } from \"./helpers\";\n\n/** @type {Map<HTMLElement, FLIPElement>} */\nlet elmMap = new Map();\n\n/**\n * Handler for a single element in a FLIP animation\n */\nexport default class FLIPElement {\n    constructor(elm, options) {\n        if (!(elm instanceof HTMLElement)) {\n            throw new TypeError(\"Element must be an HTMLElement\");\n        }\n        if (elmMap.has(elm)) {\n            let self = elmMap.get(elm);\n            this.opts = {}; // remove old options\n            self.setOptions(options);\n            return self;\n        }\n\n        this.setOptions(options);\n        elmMap.set(elm, this);\n\n        this.elm = elm;\n        this._style = {};\n    }\n\n    /**\n     * Applies options\n     * @param {Object} options The options object\n     * @param {Number} [options.duration=400] Length of animation in milliseconds\n     * @param {String} [options.ease=\"ease\"] CSS timing function to use for easing\n     * @param {String} [options.animatingClass=\"flip-animating\"] Class to apply when animating\n     * @param {String} [options.scalingClass=\"flip-scaling\"] Class to apply when scaling\n     * @param {Boolean} [options.useScale=true] Whether we should animate width/height changes by scaling\n     */\n    setOptions(options) {\n        this.opts = Object.assign({}, {\n            duration: 400,\n            ease: \"ease\",\n            animatingClass: \"flip-animating\",\n            scalingClass: \"flip-scaling\",\n            useScale: true,\n        }, this.opts, options);\n    }\n\n    /**\n     * Snapshot an elements initial position\n     * Stored in ._first\n     */\n    first() {\n        if (this._playing) {\n            this.stop();\n        }\n        this._first = getSnapshot(this.elm, this.opts.useScale);\n        this.debug(\"first\", this._first);\n\n        return this;\n    }\n\n    /**\n     * Snapshot an elements final position\n     * Stored in ._last\n     */\n    last() {\n        if (!this._first) {\n            throw new Error(\".first() must be called before .last()\");\n        }\n        this._last = getSnapshot(this.elm, this.opts.useScale);\n        this.debug(\"last\", this._last);\n\n        // save old styles for when we remove flip\n        this._style.willChange = this.elm.style.willChange;\n        this._style.transform = this.elm.style.transform;\n        this._style.transformOrigin = this.elm.style.transformOrigin;\n        this._style.transition = getTransitionFromElm(this.elm);\n        this._style.width = this.elm.style.width;\n        this._style.height = this.elm.style.height;\n\n        for (let k in this._style) {\n            let style = this._style[k];\n            this._style[k] = (style && style!==\"none\") ? style : \"\";\n        }\n\n        return this;\n    }\n\n    /**\n     * Applies a transform from ._last => ._first\n     * This moves the element back to where it was\n     */\n    invert() {\n        if (!this._first || !this._last) {\n            throw new Error(\".first() and .last() must be called before .invert()\");\n        }\n\n        const delta = getDelta(this._first, this._last);\n        const translation = `translate(${delta.left.toFixed(2)}px, ${delta.top.toFixed(2)}px)`;\n        const scaling = this.opts.useScale\n            ? `scale(${delta.width.toFixed(2)}, ${delta.height.toFixed(2)})`\n            : \"\";\n        \n        this.elm.style.transformOrigin = \"50% 50%\";\n        // if the original transform contains rotates, we need to move first\n        // (so it moves along the non-rotated axis) and scale last (so it scales\n        // along the rotated axis)\n        this.elm.style.transform = [\n            translation,\n            this._first.transform,\n            scaling\n        ].join(\" \");\n        this.elm.style.willChange = \"transform\";\n\n        // If we shouldn't scale, we should animate width/height instead\n        if (!this.opts.useScale) {\n            this.elm.style.width = `${this._first.width.toFixed(2)}px`;\n            this.elm.style.height = `${this._first.height.toFixed(2)}px`;\n        }\n\n        this.debug(\"invert\",this.elm.style.transform);\n\n        return this;\n    }\n\n    /**\n     * Plays back the animation\n     */\n    play() {\n        if (this._playPart1() === false) {\n            return this;\n        }\n\n        this.elm.offsetHeight;\n        this._applyTransition();\n        this.elm.offsetHeight;\n\n        this._playPart2();\n\n        return this;\n    }\n\n    /**\n     * Same as .play() up until the first reflow\n     * Useful if you're animating multiple elements\n     * @returns {Boolean} If false, play is stopped\n     */\n    _playPart1() {\n        if (this._playing) {\n            this.stop();\n        }\n        this._playing = true;\n\n        if (!this._checkMoved()) {\n            this.debug(\"Ending early because of no change\");\n            this._animCb = this.opts.callback;\n            this.stop();\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Same as .play() after the last reflow\n     * Useful if you're animating multiple elements\n     * @returns {Boolean} If false, play is stopped\n     */\n    _playPart2() {\n        // add our animation classes\n        this.elm.classList.add(this.opts.animatingClass);\n        if ((this._first.width !== this._last.width)\n            || (this._first.height !== this._last.height)) {\n            this.elm.classList.add(this.opts.scalingClass);\n        }\n\n        // animate to end position\n        this.elm.style.transform = this._last.transform;\n        if (!this.opts.useScale) {\n            this.elm.style.width = `${this._last.width.toFixed(2)}px`;\n            this.elm.style.height = `${this._last.height.toFixed(2)}px`;\n        }\n\n        // if cb changes before animation finishes, cache it here\n        // this could e.g. happen if we start a new animation\n        this._animCb = this.opts.callback;\n\n        this._onTransitionEnd = (e)=>{\n            if (e.target === this.elm\n                && e.propertyName === \"transform\") {\n                this.stop();\n            }\n        };\n\n        // in case transitionend isn't called (element is removed, etc.)\n        // use a timer fallback which is slightly delayed but avoids\n        // missing callbacks\n        this._timerFallback = setTimeout(\n            ()=>this._onTransitionEnd({\n                target: this.elm,\n                propertyName: \"transform\"\n            }),\n            this.opts.duration + 100\n        );\n        // wait for transitionend\n        this.elm.addEventListener(\"transitionend\", this._onTransitionEnd);\n\n        return true;\n    }\n\n    /**\n     * Check if we actually moved from first to last\n     */\n    _checkMoved() {\n        // if we're not moving at all, just end without playing\n        if (Math.abs(this._first.left - this._last.left) <= 1\n         && Math.abs(this._first.top - this._last.top) <= 1\n         && Math.abs(this._first.width - this._last.width) <= 1\n         && Math.abs(this._first.height - this._last.height) <= 1) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Applies our transition to the element\n     * Page should be reflowed before and after this is called\n     */\n    _applyTransition() {\n        const duration = (this.opts.duration/1000).toFixed(2);\n        this.elm.style.transition = [\n            this._style.transition,\n            `transform ${duration}s ${this.opts.ease}`,\n            !this.opts.useScale ? `width ${duration}s ${this.opts.ease}` : \"\",\n            !this.opts.useScale ? `height ${duration}s ${this.opts.ease}` : \"\",\n        ].filter(Boolean).join(\", \");\n    }\n\n    /**\n     * Stops an in-progress animation\n     */\n    stop() {\n        clearTimeout(this._timerFallback);\n        this.elm.removeEventListener(\"transitionend\", this._onTransitionEnd);\n        this.clean()\n            .finish();\n        return this;\n    }\n\n    /**\n     * Removes all FLIP-related data from element\n     */\n    clean() {\n        this._first = null;\n        this._last = null;\n\n        this.elm.classList.remove(this.opts.animatingClass,\n                                  this.opts.scalingClass);\n        this.elm.style.transition = this._style.transition;\n        this.elm.style.transformOrigin = this._style.transformOrigin;\n        this.elm.style.willChange = this._style.willChange;\n        this.elm.style.width = this._style.width;\n        this.elm.style.height = this._style.height;\n\n        // Firefox keeps playing playing a transition after it's removed\n        // To stop this, we change transform, reflow and then set it to what we want\n        this.elm.style.transform = this._style.transform ?\n                                    \"\" : \"translateX(10px)\";\n        this.elm.offsetHeight;\n        this.elm.style.transform  = this._style.transform;\n\n        return this;\n    }\n\n    /**\n     * Called when the animation is finished\n     * @param {Function} [callback]\n     */\n    finish() {\n        this._playing = false;        \n        if (this._animCb) {\n            this._animCb();\n            this._animCb = null;\n        }\n    }\n\n    /**\n     * Logs debug info\n     */\n    debug(method, meta) {\n        if (this.opts.debug) {\n            console.log(\"[\",this.elm,\"] \",method,meta);\n        }\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/element.js","/**\n * FLIP animation helper\n * See https://aerotwist.com/blog/flip-your-animations/\n *\n * Animation principle by Paul Lewis\n * Code by Birjolaxew\n */\n\n\"use strict\";\n// cannot use import/export because of webpack/webpack#706\nconst FLIPElement = require(\"./element.js\").default;\n\n/**\n * Animates DOM changes on specified elements\n * @param {Element|Array<Element>|String} elms  Element(s) to animate\n * @param {Function} modifier   Is called when the DOM should change\n * @param {Object} [options]    Various additional options\n * @param {Function} [options.callback] A function to be called when animation\n *                                      is done. Receives elms as parameter.\n * @param {Number} [options.duration=400] The length of the animation in milliseconds.\n * @param {String} [options.ease=\"ease\"] The CSS timing function to use\n * @param {String} [options.animatingClass=\"flip-animating\"]\n * @param {String} [options.scalingClass=\"flip-scaling\"]\n * \n * @return {Promise<Array<Element>>}    A Promise which resolves once animation \n *                                      is done.\n */\nmodule.exports = function flip(elms, modifier, options={}){\n    if (!elms || (typeof elms !== \"string\"\n                  && !(elms instanceof Array)\n                  && !(elms instanceof HTMLElement))) {\n        throw new TypeError(\"Elements must be a string, array or element\");\n    }\n    if (!modifier || !(modifier instanceof Function)) {\n        throw new TypeError(\"Modifier must be a function\");\n    }\n\n    // normalize all input types to {Array<Element>}\n    if (typeof elms === \"string\") {\n        elms = Array.from(document.querySelectorAll(elms));\n    } else if (elms instanceof HTMLElement) {\n        elms = [elms];\n    }\n\n    if (options.debug && console.groupCollapsed) {\n        console.groupCollapsed();\n    }\n\n    // make our callback a collective callback\n    let finalCallback;\n    let finalPromise = new Promise(res=>{\n        finalCallback = ()=>{\n            if (optCallback) {\n                optCallback();\n            }\n            res();\n        };\n    });\n    let optCallback = options.callback;\n    let numCalls = elms.length;\n    options.callback = ()=>{\n        if (--numCalls <= 0) {\n            finalCallback();\n        }\n    };\n\n    // convert to {Array<FLIPElement>}\n    elms = elms.map(elm=>{\n        if (!(elm instanceof HTMLElement)) {\n            throw new TypeError(\"Array must only contain elements\");\n        }\n        return new FLIPElement(elm, options);\n    });\n\n    // ===\n    // FLIP elements\n    // ===\n    elms.forEach(elm=>elm.first()); // reflow: read\n    modifier(); // reflow: write\n    elms.forEach(elm=>elm.last()); // reflow: read\n    elms.forEach(elm=>elm.invert()); // reflow: write\n    elms = elms.map(elm=>{ // reflow: write\n        if (elm._playPart1() === false) {\n            options.callback();\n            return false;\n        }\n        return elm;\n    }).filter(Boolean);\n    document.body.offsetTop; // force reflow\n    elms.forEach(elm=>elm._applyTransition()); // reflow: write\n    document.body.offsetTop; // force reflow\n    elms.forEach(elm=>elm._playPart2());\n\n    if (options.debug && console.groupCollapsed) {\n        console.groupEnd();\n    }\n\n    // return a Promise\n    return finalPromise;\n};\nmodule.exports.FLIPElement = FLIPElement;\n\n\n// WEBPACK FOOTER //\n// ./src/flippy.js","\"use strict\";\n\n/**\n * Gets a snapshot of an element\n * Returns an object with format\n * {\n *   left: <Number>, top: <Number>,\n *   width: <Number>, height: <Number>,\n *   transform: <String>\n * }\n */\nexport function getSnapshot(elm, fromCenter) {\n    let pos = getClientRect(elm);\n    let styles = window.getComputedStyle(elm);\n    return { // positions are related to center\n        left: pos.left + (fromCenter ? pos.width/2 : 0),\n        top: pos.top + (fromCenter ? pos.height/2 : 0),\n        width: pos.width,\n        height: pos.height,\n        \n        transform: styles.transform === \"none\" || !styles.transform ?\n                        \"\" : styles.transform\n    };\n}\n\n/**\n * Gets the difference between two snapshots\n * Width/height are scales, left/top are pixel differences\n */\nexport function getDelta(alpha, beta) {\n    let delta = {\n        left: alpha.left - beta.left,\n        top: alpha.top - beta.top,\n        width: alpha.width / beta.width,\n        height: alpha.height / beta.height\n    };\n\n    if (alpha.width === 0 && alpha.height === 0) {\n        // the element probably wasn't in the DOM at the time\n        // don't animate left/top\n        delta.left = delta.top = 0;\n    }\n\n    return delta;\n}\n\n/**\n * Returns the client rectangle of an element w/o transforms\n */\nexport function getClientRect(elm) {\n    let rect = {\n        width: elm.offsetWidth,\n        height: elm.offsetHeight,\n        left: elm.offsetLeft,\n        top: elm.offsetTop\n    };\n    let _isFixed = window.getComputedStyle(elm).position === \"fixed\";\n\n    // offsetLeft/-Top relates to the offsetParent\n    // we want it to relate to the window\n    while ((elm = elm.offsetParent) && elm !== document.body\n                                    && elm !== document.documentElement) {\n        rect.left += elm.offsetLeft;\n        rect.top += elm.offsetTop;\n    }\n\n    // fixed elements have .offsetParent === body\n    if (_isFixed) {\n        let doc = document.documentElement;\n        rect.left += (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);\n        rect.top += (window.pageYOffset || doc.scrollTop)  - (doc.clientTop || 0);\n    }\n\n    return rect;\n}\n\n/**\n * Get the applied transition from an element\n * @returns {String}\n */\nexport function getTransitionFromElm(elm) {\n    let styles = window.getComputedStyle(elm);\n    return `${styles.transitionProperty} ${styles.transitionDuration} ${styles.transitionTimingFunction} ${styles.transitionDelay}`;\n}\n\n\n// WEBPACK FOOTER //\n// ./src/helpers.js"],"sourceRoot":""}