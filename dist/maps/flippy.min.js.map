{"version":3,"sources":["flippy.js"],"names":["root","factory","define","amd","jQuery","flip","fn","apply","this","toArray","concat","arguments","module","exports","snapshot","elements","outp","i","j","length","getBoundingClientRect","DEFAULTS","duration","ease","animatingClass","scalingClass","doChange","options","k","hasOwnProperty","console","warn","old","elm","_old","_new","delta","left","width","top","height","scaleWidth","scaleHeight","moving","toFixed","scaling","style","transform","trim","classList","add","offsetHeight","transition","addEventListener","self","e","propertyName","remove","removeEventListener","_onEnd","_times","callback"],"mappings":"CAUA,SAAUA,EAAMC,GACf,GAAsB,kBAAXC,SAAyBA,OAAOC,IAC1CD,OAAOD,OACD,IAAsB,kBAAXG,QAAuB,CACxC,GAAIC,GAAOJ,GACXG,QAAOE,GAAGD,KAAO,WAGhB,MADAA,GAAKE,MAAM,KAAMC,KAAKC,UAAUC,OAAOC,YAChCH,UAEoB,gBAAXI,SAAuBA,OAAOC,QAC/CD,OAAOC,QAAUZ,IAEjBD,EAAKK,KAAOJ,KAEXO,KAAM,WA4GR,QAASM,GAASC,GAEjB,IAAK,GADDC,MACKC,EAAI,EAAGC,EAAIH,EAASI,OAAYD,EAAJD,IAASA,EAC7CD,EAAKC,GAAKF,EAASE,GAAGG,uBAGvB,OAAOJ,GAjHR,GAAIK,IACHC,SAAU,GACVC,KAAM,OACNC,eAAgB,iBAChBC,aAAc,gBAUXpB,EAAO,SAAcU,EAAUW,EAAUC,GAC5CA,EAAUA,KACV,KAAK,GAAIC,KAAKP,GACRM,EAAQE,eAAeD,KAC3BD,EAAQC,GAAKP,EAASO,GAIxB,MAAMD,EAAQL,WAAaP,GAAgC,IAApBA,EAASI,OAC/C,MAAOW,SAAQC,KAAK,6DAGrBhB,GAAWA,EAASI,OAASJ,GAAYA,EAIzC,IAAIiB,GAAMlB,EAASC,EAGnBW,IAGA,KAAK,GAAIT,GAAI,EAAGC,EAAIH,EAASI,OAAYD,EAAJD,IAASA,EAAG,CAChD,GAAIgB,GAAMlB,EAASE,GACfiB,EAAOF,EAAIf,GACXkB,EAAOF,EAAIb,wBAITgB,GACFC,KAAOH,EAAKG,KAAKH,EAAKI,MAAM,GAAMH,EAAKE,KAAKF,EAAKG,MAAM,GACvDC,IAAML,EAAKK,IAAIL,EAAKM,OAAO,GAAML,EAAKI,IAAIJ,EAAKK,OAAO,GACtDC,WAAYP,EAAKI,MAAQH,EAAKG,MAC9BI,YAAaR,EAAKM,OAASL,EAAKK,QAI9BG,EAAmC,SAA1BP,EAAMC,KAAKO,QAAQ,IACC,SAAzBR,EAAMG,IAAIK,QAAQ,GACtBC,EAA0C,SAAhCT,EAAMK,WAAWG,QAAQ,IACE,SAAjCR,EAAMM,YAAYE,QAAQ,EAElCX,GAAIa,MAAMC,YACPJ,EAAS,aACVP,EAAMC,KAAKO,QAAQ,GAAG,MACtBR,EAAMG,IAAIK,QAAQ,GAAG,MAChB,KACPC,EAAU,UACVT,EAAMK,WAAWG,QAAQ,GAAG,IAC5BR,EAAMM,YAAYE,QAAQ,GAC3B,IAAM,KAAKI,QAGRL,GAAUE,IACbZ,EAAIgB,UAAUC,IAAIvB,EAAQH,gBAEvBqB,GACHZ,EAAIgB,UAAUC,IAAIvB,EAAQF,cAQ5B,KAHCV,EAAS,GAAGoC,aAGRlC,EAAI,EAAOC,EAAJD,IAASA,EACpBF,EAASE,GAAG6B,MAAMM,WAAa,aAAazB,EAAQL,SAAS,KAAKK,EAAQJ,KAC1ER,EAASE,GAAG6B,MAAMC,UAAY,GAG9BhC,EAASE,GAAGoC,iBAAiB,gBAAiB,QAASC,GAAKC,GACpC,cAAnBA,EAAEC,eAGNhD,KAAKsC,MAAMM,WAAa,GACxB5C,KAAKyC,UAAUQ,OAAO9B,EAAQH,eAAgBG,EAAQF,cACtDjB,KAAKkD,oBAAoB,gBAAiBJ,GAG1CK,MAKF,IAAIC,GAAS,EACTD,EAAS,aACNC,GAAU7C,EAASI,QAAUQ,EAAQkC,UAC1ClC,EAAQkC,YAgBX,OAAOxD","file":"flippy.min.js","sourcesContent":["/**\r\n * FLIP animation helper\r\n * See https://aerotwist.com/blog/flip-your-animations/\r\n *\r\n * Animation principle by Paul Lewis\r\n * Code by Birjolaxew\r\n *\r\n * TODO: parse existing transform/transition values, so we don't overwrite unnecesarrily\r\n */\r\n\r\n(function(root, factory){\r\n\tif (typeof define === \"function\" && define.amd) { // AMD support\r\n\t\tdefine(factory);\r\n\t} else if (typeof jQuery === \"function\") { // jQuery support\r\n\t\tvar flip = factory();\r\n\t\tjQuery.fn.flip = function(){\r\n\t\t\t// call flip with elements set to this collection\r\n\t\t\tflip.apply(null, this.toArray().concat(arguments));\r\n\t\t\treturn this;\r\n\t\t};\r\n\t} else if (typeof module === \"object\" && module.exports) { // CommonJS support\r\n\t\tmodule.exports = factory();\r\n\t} else {\r\n\t\troot.flip = factory();\r\n\t}\r\n})(this, function(){\r\n\tvar DEFAULTS = {\r\n\t\tduration: .4, // duration of animation in seconds\r\n\t\tease: \"ease\", // name of CSS easing function to use\r\n\t\tanimatingClass: \"flip-animating\", // class to apply to elements that are animating\r\n\t\tscalingClass: \"flip-scaling\" // class to apply to elements that scale\r\n\t\t//callback: <function> // function to call when the animation has ended\r\n\t};\r\n\r\n\t/**\r\n\t * Animate a group of elements using the FLIP principle\r\n\t * @param  {Array|NodeList} elements List of elements animate\r\n\t * @param  {Function} doChange Callback which triggers the change in DOM\r\n\t * @param  {Object} options  Options object. See defaults (above) for details\r\n\t */\r\n\tvar flip = function flip(elements, doChange, options) {\r\n\t\toptions = options || {};\r\n\t\tfor (var k in DEFAULTS) { // fill missing options with defaults\r\n\t\t\tif (!options.hasOwnProperty(k)) {\r\n\t\t\t\toptions[k] = DEFAULTS[k];\r\n\t\t\t}\r\n\t\t}\r\n\t\t// fail early if we shouldn't animate, or if we have no elements\r\n\t\tif (!+options.duration || !elements || elements.length === 0) {\r\n\t\t\treturn console.warn(\"[FLIP] Tried to FLIP empty element set, or with 0 duration\");\r\n\t\t}\r\n\t\t// support single element\r\n\t\telements = elements.length ? elements : [elements];\r\n\r\n\t\t// == Start FLIP == //\r\n\t\t// get all positions/sizes of elements\r\n\t\tvar old = snapshot(elements);\r\n\r\n\t\t// ask caller to do DOM change\r\n\t\tdoChange();\r\n\r\n\t\t// transform back to old positions\r\n\t\tfor (var i = 0, j = elements.length; i < j; ++i) {\r\n\t\t\tvar elm = elements[i],\r\n\t\t\t    _old = old[i],\r\n\t\t\t    _new = elm.getBoundingClientRect();\r\n\r\n\t\t\t// calculating offset from middle of object\r\n\t    // this works with flexbox (calculating from corner does not)\r\n\t    var delta = {\r\n\t      left: (_old.left+_old.width/2) - (_new.left+_new.width/2),\r\n\t      top: (_old.top+_old.height/2) - (_new.top+_new.height/2),\r\n\t      scaleWidth: _old.width / _new.width,\r\n\t      scaleHeight: _old.height / _new.height\r\n\t    };\r\n\r\n\t    // create transform\r\n\t    var moving = delta.left.toFixed(2) !== \"0.00\" || // if either left or top delta isn't 0\r\n\t    \t\t\t\t\t\t\t\tdelta.top.toFixed(2) !== \"0.00\";\r\n\t    var scaling = delta.scaleWidth.toFixed(2) !== \"1.00\" || // if either width or height scale isn't 1\r\n\t    \t\t\t\t\t\t\t\tdelta.scaleHeight.toFixed(2) !== \"1.00\";\r\n\r\n\t    elm.style.transform = \r\n\t    \t((moving ? \"translate(\" + // if we're moving, add translate transform\r\n\t    \t\tdelta.left.toFixed(2)+\"px,\" +\r\n\t    \t\tdelta.top.toFixed(2)+\"px\" +\r\n\t    \t\")\" : \"\") +\r\n\t\t\t\t(scaling ? \" scale(\" + // if we're scaling, add scale transform\r\n\t\t\t\t\tdelta.scaleWidth.toFixed(2)+\",\" +\r\n\t\t\t\t\tdelta.scaleHeight.toFixed(2) +\r\n\t\t\t\t\")\" : \"\")).trim();\r\n\r\n\t    // add appropriate classes\r\n\t\t\tif (moving || scaling) {\r\n\t\t\t\telm.classList.add(options.animatingClass);\r\n\t\t\t}\r\n\t\t\tif (scaling) {\r\n\t\t\t\telm.classList.add(options.scalingClass);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// force a reflow\r\n\t\t+elements[0].offsetHeight;\r\n\r\n\t\t// then add CSS animations\r\n\t\tfor (i = 0; i < j; ++i) {\r\n\t\t\telements[i].style.transition = \"transform \"+options.duration+\"s \"+options.ease;\r\n\t\t\telements[i].style.transform = \"\";\r\n\r\n\t\t\t// bind listener for transitionend\r\n\t\t\telements[i].addEventListener(\"transitionend\", function self(e){\r\n\t\t\t\tif (e.propertyName !== \"transform\") return;\r\n\r\n\t\t\t\t// remove our stuff\r\n\t\t\t\tthis.style.transition = \"\";\r\n\t\t\t\tthis.classList.remove(options.animatingClass, options.scalingClass);\r\n\t\t\t\tthis.removeEventListener(\"transitionend\", self); // including this listener\r\n\r\n\t\t\t\t// call callback once everything is done\r\n\t\t\t\t_onEnd();\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\t// called once a transition has ended; once every element calls it, it calls callback\r\n\t\tvar _times = 0;\r\n\t\tvar _onEnd = function(){\r\n\t\t\tif (++_times >= elements.length && options.callback) {\r\n\t\t\t\toptions.callback();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/** Helper functions **/\r\n\tfunction snapshot(elements) {\r\n\t\tvar outp = [];\r\n\t\tfor (var i = 0, j = elements.length; i < j; ++i) {\r\n\t\t\toutp[i] = elements[i].getBoundingClientRect();\r\n\t\t\t// TODO: other properties (eg. opacity) ?\r\n\t\t}\r\n\t\treturn outp;\r\n\t}\r\n\r\n\t// return the flip function\r\n\treturn flip;\r\n});"],"sourceRoot":"/source/"}