{"version":3,"sources":["flippy.js"],"names":["root","factory","define","amd","jQuery","flip","fn","apply","this","toArray","concat","slice","call","arguments","module","exports","snapshot","elements","outp","i","j","length","getBoundingClientRect","DEFAULTS","duration","ease","animatingClass","scalingClass","doChange","options","_onEnd","_times","callback","k","hasOwnProperty","old","elm","_old","_new","delta","left","width","top","height","scaleWidth","scaleHeight","bottom","right","undefined","moving","toFixed","scaling","style","transform","trim","classList","add","reflowed","offsetHeight","transition","addEventListener","self","e","propertyName","remove","removeEventListener"],"mappings":"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","file":"flippy.min.js","sourcesContent":["/**\r\n * FLIP animation helper\r\n * See https://aerotwist.com/blog/flip-your-animations/\r\n *\r\n * Animation principle by Paul Lewis\r\n * Code by Birjolaxew\r\n *\r\n * TODO: parse existing transform/transition values, so we don't overwrite unnecesarrily\r\n */\r\n\r\n(function(root, factory){\r\n\tif (typeof define === \"function\" && define.amd) { // AMD support\r\n\t\tdefine(factory);\r\n\t} else if (typeof jQuery === \"function\") { // jQuery support\r\n\t\tvar flip = factory();\r\n\t\tjQuery.fn.flip = function(){\r\n\t\t\t// call flip with elements set to this collection\r\n\t\t\tflip.apply(null, [this.toArray()].concat([].slice.call(arguments)));\r\n\t\t\treturn this;\r\n\t\t};\r\n\t} else if (typeof module === \"object\" && module.exports) { // CommonJS support\r\n\t\tmodule.exports = factory();\r\n\t} else {\r\n\t\troot.flip = factory();\r\n\t}\r\n})(this, function(){\r\n\tvar DEFAULTS = {\r\n\t\tduration: .4, // duration of animation in seconds\r\n\t\tease: \"ease\", // name of CSS easing function to use\r\n\t\tanimatingClass: \"flip-animating\", // class to apply to elements that are animating\r\n\t\tscalingClass: \"flip-scaling\" // class to apply to elements that scale\r\n\t\t//callback: <function> // function to call when the animation has ended\r\n\t};\r\n\r\n\t/**\r\n\t * Animate a group of elements using the FLIP principle\r\n\t * @param  {Array|NodeList} elements List of elements animate\r\n\t * @param  {Function} doChange Callback which triggers the change in DOM\r\n\t * @param  {Object} options  Options object. See defaults (above) for details\r\n\t */\r\n\tvar flip = function flip(elements, doChange, options) {\r\n\t\toptions = options || {};\r\n\t\tfor (var k in DEFAULTS) { // fill missing options with defaults\r\n\t\t\tif (!options.hasOwnProperty(k)) {\r\n\t\t\t\toptions[k] = DEFAULTS[k];\r\n\t\t\t}\r\n\t\t}\r\n\t\t// fail early if we shouldn't animate, or if we have no elements\r\n\t\tif (!+options.duration || !elements || elements.length === 0) {\r\n\t\t\t// console.warn(\"[FLIP] Tried to FLIP empty element set, or with 0 duration\");\r\n\t\t\tdoChange();\r\n\t\t\tif (options.callback) {\r\n\t\t\t\toptions.callback();\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t// support single element\r\n\t\telements = elements.length ? elements : [elements];\r\n\r\n\t\t// == Start FLIP == //\r\n\t\t// get all positions/sizes of elements\r\n\t\tvar old = snapshot(elements);\r\n\r\n\t\t// ask caller to do DOM change\r\n\t\tdoChange();\r\n\r\n\t\t// transform back to old positions\r\n\t\tfor (var i = 0, j = elements.length; i < j; ++i) {\r\n\t\t\tvar elm = elements[i],\r\n\t\t\t    _old = old[i],\r\n\t\t\t    _new = elm.getBoundingClientRect();\r\n\r\n\t\t\t// calculating offset from middle of object\r\n\t    // this works with flexbox (calculating from corner does not)\r\n\t    var delta = {\r\n\t      left: (_old.left+_old.width/2) - (_new.left+_new.width/2),\r\n\t      top: (_old.top+_old.height/2) - (_new.top+_new.height/2),\r\n\t      scaleWidth: _old.width / _new.width,\r\n\t      scaleHeight: _old.height / _new.height\r\n\t    };\r\n\r\n\t    // if the element was removed, it won't have any data; remove it from the set (but don't mess with index's)\r\n\t    // we'll also remove any element that doesn't need to be animated (ie. no change)\r\n\t\t\tif (!(_new.bottom || _new.height || _new.left || _new.right || _new.top || _new.width)\r\n\t\t\t\t\t|| (delta.left === 0 && delta.top === 0 && delta.scaleWidth === 1 && delta.scaleHeight === 1)) {\r\n\t\t\t\telements[i] = undefined;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t    // create transform\r\n\t    var moving = delta.left.toFixed(2) !== \"0.00\" || // if either left or top delta isn't 0\r\n\t    \t\t\t\t\t\t\t\tdelta.top.toFixed(2) !== \"0.00\";\r\n\t    var scaling = delta.scaleWidth.toFixed(2) !== \"1.00\" || // if either width or height scale isn't 1\r\n\t    \t\t\t\t\t\t\t\tdelta.scaleHeight.toFixed(2) !== \"1.00\";\r\n\r\n\t    elm.style.transform = \r\n\t    \t((moving ? \"translate(\" + // if we're moving, add translate transform\r\n\t    \t\tdelta.left.toFixed(2)+\"px,\" +\r\n\t    \t\tdelta.top.toFixed(2)+\"px\" +\r\n\t    \t\")\" : \"\") +\r\n\t\t\t\t(scaling ? \" scale(\" + // if we're scaling, add scale transform\r\n\t\t\t\t\tdelta.scaleWidth.toFixed(2)+\",\" +\r\n\t\t\t\t\tdelta.scaleHeight.toFixed(2) +\r\n\t\t\t\t\")\" : \"\")).trim();\r\n\r\n\t\t    // add appropriate classes\r\n\t\t\tif (moving || scaling) {\r\n\t\t\t\telm.classList.add(options.animatingClass);\r\n\t\t\t}\r\n\t\t\tif (scaling) {\r\n\t\t\t\telm.classList.add(options.scalingClass);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// called once a transition has ended; once every element calls it, it calls callback\r\n\t\tvar _times = 0;\r\n\t\tfunction _onEnd(){\r\n\t\t\tif (++_times >= elements.length && options.callback) {\r\n\t\t\t\toptions.callback();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar reflowed = false;\r\n\t\t// add CSS animations\r\n\t\tfor (i = 0; i < j; ++i) {\r\n\t\t\tif (!elements[i]) { // if the element was removed earlier, skip\r\n\t\t\t\t_onEnd();\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tif (!reflowed) {\r\n\t\t\t\t+elements[i].offsetHeight; // force a reflow\r\n\t\t\t\treflowed = true;\r\n\t\t\t}\r\n\r\n\t\t\telements[i].style.transition = \"transform \"+options.duration+\"s \"+options.ease;\r\n\t\t\telements[i].style.transform = \"\";\r\n\r\n\t\t\t// bind listener for transitionend\r\n\t\t\telements[i].addEventListener(\"transitionend\", function self(e){\r\n\t\t\t\tif (e.propertyName !== \"transform\") return;\r\n\r\n\t\t\t\t// remove our stuff\r\n\t\t\t\tthis.style.transition = \"\";\r\n\t\t\t\tthis.classList.remove(options.animatingClass, options.scalingClass);\r\n\t\t\t\tthis.removeEventListener(\"transitionend\", self); // including this listener\r\n\r\n\t\t\t\t// call callback once everything is done\r\n\t\t\t\t_onEnd();\r\n\t\t\t})\r\n\t\t}\r\n\t}\r\n\r\n\t/** Helper functions **/\r\n\tfunction snapshot(elements) {\r\n\t\tvar outp = [];\r\n\t\tfor (var i = 0, j = elements.length; i < j; ++i) {\r\n\t\t\toutp[i] = elements[i].getBoundingClientRect();\r\n\t\t\t// TODO: other properties (eg. opacity) ?\r\n\t\t}\r\n\t\treturn outp;\r\n\t}\r\n\r\n\t// return the flip function\r\n\treturn flip;\r\n});"],"sourceRoot":"/source/"}